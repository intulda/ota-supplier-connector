# ota-supplier-connector

## 개요

ota-supplier-connector는
여러 OTA(Online Travel Agency) 공급사와의 숙소 데이터를 안정적으로 연동하기 위한 백엔드 연동 모듈입니다.

본 프로젝트는 단순 CRUD가 아닌,

- 외부 시스템 연동에서 발생하는 실패 / 재시도
- 공급사별 상이한 API 규격
- 중복 데이터 적재 리스크

를 실무 관점에서 어떻게 설계하고 해결하는지를 보여주는 것을 목표로 합니다.

## 이 프로젝트 목적

OTA 연동 도메인에서 가장 위험한 문제는 다음 두 가지입니다. \
재시도로 인한 중복 적재 / 중복 예약 \
장애 발생 시 원인 파악이 어려운 로그 구조 \
본 프로젝트는 중복 적재 문제는 도메인 멱등성 설계를 통해 실제로 해결하고,
로그 구조 및 재시도 전략은 Adapter 계층에서 확장 가능하도록 설계 방향을 정의합니다.

## 코드 디자인 우려되는 사항

### Idempotency

외부 공급사 API는 네트워크 장애, 타임아웃 등으로 인해 \
동일 요청이 여러 번 재시도될 수 있습니다.

이때 가장 치명적인 문제는
- 동일 숙소 데이터의 중복 적재
- (실제 서비스라면) 중복 예약 발생

#### 해결 전략

- 공급사에서 내려주는 고유 식별자(externalId)
- 내부에서 정의한 공급사 타입(supplierType)

를 복합 유니크 키로 사용하여 여러 번 요청이 와도 결과가 동일하게 유지되도록 설계합니다.

이를 통해 재시도 시에도 데이터 정합성 보장 외부 API 신뢰도가 낮아도 내부 시스템 안정성 유지

`재시도는 시스템의 실패가 아니라, 전제 조건이다` 라는 관점에서 설계했습니다.


### Observability 

연동 시스템에서 장애가 발생했을 때 가장 중요한 것은 **얼마나 빨리 원인을 특정할 수 있는가** 입니다.

```java
log.error("API failed");
```

해당 로그로는 많은 정보를 알 수 없습니다.
- 어떤 공급사인지 
- 어디서 에러가 났는지
- 네트워크 문제인지, 데이터 문제인지 

#### 해결전략

공급사 단위로 로그 포맷을 강제합니다.

```
[SUPPLIER=EXPEDIA][STEP=FETCH][RESULT=FAILED][REASON=TIMEOUT]
```

이를 통해 로그만 보고도 장애 공급사 즉시 식별 \
재현 없이 운영 대응 가능 \
모니터링 시스템 연동에 유리한 구조

### 테스트 전략

- 외부 OTA 연동에서 재시도/동시성으로 인한 중복 적재를 방지하기 위해 (SupplierType, ExternalId) 기반 멱등성을 구현했습니다.
- Application Layer는 유스케이스 집계 및 실패 변환을 담당하고, Domain Layer는 규칙만 수행합니다.
- 도메인 규칙은 Fake Repository 기반 단위 테스트로 검증했습니다.
- 유스케이스 집계/예외 변환은 Mock 기반 단위 테스트로 검증했습니다.

### 왜 분산락을 사용하지 않았는가?

본 프로젝트에서는 동시 요청을 실패로 처리하지 않고 동일한 결과로 수렴시키는 것을 목표로 했습니다.
(supplierType, externalId)를 기준으로 멱등성을 보장하고, 중복 요청 발생 시 기존 데이터를 반환하도록 설계하여 경쟁 상황을 비즈니스 로직으로 제어했습니다.
따라서 요청 간 순서를 강제하는 분산락 대신, 결과가 하나로 수렴하도록 모델링하는 방식이 더 단순하고 확장 가능한 선택이라고 판단했습니다.

### 왜 DB 제약을 최후 방어선으로 두었는가

비즈니스 규칙에 따른 판단은 Application 레이어에서 수행하고, DB는 최종적인 데이터 정합성을 보장하는 역할로 제한했습니다.
DB 제약만으로 중복을 제어할 경우 예외 기반 흐름이 증가하고 원인 파악이 어려워질 수 있기 때문에, Application 단계에서 먼저 멱등성을 판단하여 정상 흐름으로 처리하도록 설계했습니다.
DB의 Unique 제약은 예외적인 경쟁 상황에서 데이터 무결성을 보장하는 최종 방어선으로 사용했습니다.
